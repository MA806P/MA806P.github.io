<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OC,基础," />










<meta name="description" content="本文是对 iOS 中 GCD (Grand Central Dispatch) 的整理小结。总结了有关线程的知识点、GCD 的对应的使用方法。   线程与进程线程是系统能够进行运算调度的最小单位，线程被包含在进程中，是进程中的实际运作单位。一个程序至少有一个进程，一个进程至少有一个线程。一个进程中可以并发多个线程，执行不同的任务，可充分利用系统资源，提高性能。   进程是系统进行资源分配和调度的一">
<meta name="keywords" content="OC,基础">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD 多线程 小结">
<meta property="og:url" content="http:&#x2F;&#x2F;yupeng.fun&#x2F;2019&#x2F;10&#x2F;30&#x2F;gcd&#x2F;index.html">
<meta property="og:site_name" content="Peng&#39;s blog">
<meta property="og:description" content="本文是对 iOS 中 GCD (Grand Central Dispatch) 的整理小结。总结了有关线程的知识点、GCD 的对应的使用方法。   线程与进程线程是系统能够进行运算调度的最小单位，线程被包含在进程中，是进程中的实际运作单位。一个程序至少有一个进程，一个进程至少有一个线程。一个进程中可以并发多个线程，执行不同的任务，可充分利用系统资源，提高性能。   进程是系统进行资源分配和调度的一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yupeng.fun&#x2F;images&#x2F;2019&#x2F;gcd-1.png">
<meta property="og:updated_time" content="2021-07-02T07:07:14.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yupeng.fun&#x2F;images&#x2F;2019&#x2F;gcd-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: false,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yupeng.fun/2019/10/30/gcd/"/>





  <title>GCD 多线程 小结 | Peng's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Peng's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yupeng.fun/2019/10/30/gcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MA806P">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avator-default.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GCD 多线程 小结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-30T23:42:17+08:00">
                2019-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文是对 iOS 中 GCD (Grand Central Dispatch) 的整理小结。总结了有关线程的知识点、GCD 的对应的使用方法。  </p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>线程是系统能够进行运算调度的最小单位，线程被包含在进程中，是进程中的实际运作单位。一个程序至少有一个进程，一个进程至少有一个线程。一个进程中可以并发多个线程，执行不同的任务，可充分利用系统资源，提高性能。  </p>
<p>进程是系统进行资源分配和调度的一个独立单位。线程自己基本上不拥有系统资源，同一个进程中的多个线程共享进程所拥有的资源。当多个线程对同一个资源进行操作的时候需要注意线程安全问题。  </p>
<p>iOS 中的程序启动，创建好一个进程的同时， 一个线程便开始运行，这个线程叫主线程。有关界面的显示操作，即 UIKit 的操作在主线程进行。 有关多线程的操作，主要依靠 GCD 和 NSOperation。  </p>
<p><strong>相关概念</strong>  </p>
<ul>
<li><p>串行（Serial）：在固定时间内只能执行单个任务。  </p>
</li>
<li><p>并行（Parallel）：在固定时间内同时执行多个任务。  </p>
</li>
<li><p>并发（Concurrent）：在固定时间内可以执行多个任务。它和并行（Parallel）的区别在于，并发不会同时执行多个任务，而是通过在任务间不断切换去完成多个任务，多个任务在同一时间间隔内执行。  </p>
</li>
<li><p>同步（Sync）：会把当前的任务加入到队列中，除非该任务执行完成，线程才会返回继续运行，也就是说同步会阻塞线程。任务在执行和结束一定遵循先后顺序，即先执行的任务一定先结束。  </p>
</li>
<li><p>异步（Async）：会把当前的任务加入到队列中，但它会立刻返回，无需等任务执行完成，也就是说异步不会阻塞线程。任务在执行和结束不遵循先后顺序。可能先执行的任务先结束，也可能后执行的任务先结束。  </p>
</li>
</ul>
<p>串行是同步的执行方式。<br>并发和并行是异步执行的两种执行方式。  </p>
<br>

<h3 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h3><p>GCD (Grand Central Dispatch) 是一个异步执行的技术，将应用程序中线程管理的代码在系统层级中实现，开发者只要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程执行任务，就是用非常简洁的方法，实现了复杂繁琐的多线程编程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">      //执行任务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 Block 语法定义要执行的任务，通过 dispatch_async 函数将任务追加到 queue 队列中，这样就可以使指定的 Block 在另一线程中执行。  </p>
<h4 id="1、Dispatch-Queue"><a href="#1、Dispatch-Queue" class="headerlink" title="1、Dispatch Queue"></a>1、Dispatch Queue</h4><p>两种队列：串行队列 Serial Dispatch Queue；并发队列 Concurrent Dispatch Queue。  </p>
<h5 id="1-1-创建队列的方法："><a href="#1-1-创建队列的方法：" class="headerlink" title="1.1 创建队列的方法："></a>1.1 创建队列的方法：</h5><p>1、dispatch_queue_create 函数  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列 DISPATCH_QUEUE_SERIAL，可写成 NULL</span><br><span class="line">// 并发队列 DISPATCH_QUEUE_CONCURRENT</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数指定队列的名称，方便调试。</li>
<li>第二个参数 Serial Dispatch Queue 指定为 NULL，Concurrent Dispatch Queue 指定为 DISPATCH_QUEUE_CONCURRENT。</li>
<li>返回值为 Dispatch Queue，dispatch_queue_t 类型</li>
</ul>
<p>2、获取系统标准提供的 Dispatch Queue<br>不用特意创建生成 Dispatch Queue 系统也会给我们提供几个，Main Dispatch Queue 和 Global Dispatch Queue  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<ul>
<li>Main Dispatch Queue 是在主线程执行的队列 ，主线程只有1个，所以 Main Dispatch Queue 是串行队列 Serial Dispatch Queue。有关用户界面更新等一些必须在主线程中执行的处理，需要追加到 Main Dispatch Queue 中处理。这与 performSelectorOnMainThread 执行方法相同。  </li>
<li>Global Dispatch Queue 是所有应用程序都能使用的 Concurrent Dispatch Queue，没有必要通过 dispatch_queue_create 生成，只要获取 Global Dispatch Queue 使用即可。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Global Dispatch Queue 有4个执行优先级，向队列中追加处理时，应选择与处理内容对应的优先级。</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2      //高优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0   //默认优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)    //低优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN  //后台优先级</span><br></pre></td></tr></table></figure>
<br>

<h5 id="1-2-串行队列"><a href="#1-2-串行队列" class="headerlink" title="1.2 串行队列"></a>1.2 串行队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">//end</span><br><span class="line">//1 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>串行队列，要等待当前任务处理结束，1执行结束，接着执行2，如此重复，同时执行的处理数只能有一个，顺序执行任务。<br>一旦生成 Serial Dispatch Queue 并追加处理，系统对于一个 Serial Dispatch Queue 就只生成并使用一个线程。<br>在一个 Serial Dispatch Queue 中只能执行一个追加处理，但如果生成多个 Serial Dispatch Queue 将并发执行，各个执行一个处理，即为同时执行多个处理。<br><br></p>
<h5 id="1-3-并发队列"><a href="#1-3-并发队列" class="headerlink" title="1.3 并发队列"></a>1.3 并发队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">//end</span><br><span class="line">//2 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">//1 --- &lt;NSThread: 0x600003fded40&gt;&#123;number = 8, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>并发队列，使用多个线程同时执行多个处理，不用等待当前任务处理结束，就开始执行后面的任务，可并发执行多个任务，得到的结果打印顺序，不会按照代码追加到队列的顺序，是打乱的。<br><br></p>
<h4 id="2、dispatch-sync-同步操作函数、dispatch-async-异步操作函数"><a href="#2、dispatch-sync-同步操作函数、dispatch-async-异步操作函数" class="headerlink" title="2、dispatch_sync 同步操作函数、dispatch_async 异步操作函数"></a>2、dispatch_sync 同步操作函数、dispatch_async 异步操作函数</h4><ul>
<li><p>dispatch_sync 函数，将指定的 block 同步地追加到指定的 Dispatch Queue 中，在追加 block 任务结束之前，dispatch_sync 函数会一直等待。  </p>
</li>
<li><p>dispatch_async 函数，将指定的 block 任务异步地追加到指定的 Dispatch Queue 中，dispatch_async 函数不做任何等待。  </p>
</li>
</ul>
<h5 id="2-1-在串行队列上进行同步-异步操作"><a href="#2-1-在串行队列上进行同步-异步操作" class="headerlink" title="2.1 在串行队列上进行同步/异步操作"></a>2.1 在串行队列上进行同步/异步操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;11 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;22 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;33 --- &quot;);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//11 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//22 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//33 ---</span><br></pre></td></tr></table></figure>
<p>在串行队列上进行同步操作，所有任务将顺序执行。不会开启线程，在主线程上顺序执行任务，相当于直接执行任务的代码。<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;a --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;--- %d&quot;, sum);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;aa --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;b --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;bb --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;c --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;cc ---&quot;);</span><br><span class="line"></span><br><span class="line">//aa --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//a --- &lt;NSThread: 0x6000026d3000&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//bb --- &lt;NSThread: 0x600002662200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//cc ---</span><br><span class="line">//--- 100000</span><br><span class="line">//b --- &lt;NSThread: 0x6000026d3000&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">//c --- &lt;NSThread: 0x6000026d3000&gt;&#123;number = 8, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在串行队列上进行异步操作，如上代码，打印顺序不固定，但是 aa – bb – cc 一定是按照这个顺序打印的。a – b – c – 一定是按照这个顺序处理队列的任务的，异步执行另开一个线程，执行串行队列里的任务，一次只能执行一个任务，a 执行完，再执行 b，以此类推。<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial3&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//4 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x6000010d21c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x600001086880&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在串行队列上进行，同步、异步嵌套。串行队列一次只能执行一个任务，同步执行的函数要等待 block 任务执行完成后，再去执行嵌套的串行队列上的 block 任务，所以打印的顺序为 1 – 2– 4 – 3，5的顺序不固定，可能在 3 前，可能在 3 后。一定是 1 – 2 – 4 先执行完，然后串行队列才能让 3 执行，一个任务执行完，才能执行下一个任务。<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial5&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x600001ea6280&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x600001efc6c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x600001ea6280&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//崩溃，死锁</span><br></pre></td></tr></table></figure>
<p>在串行队列上进行，异步、同步嵌套。如上代码，会产生死锁。<br>先异步执行 block 的任务，任务里面嵌套的，同步执行的任务也在串行队列中，需要等待要同步执行的任务完成才能返回，但是串行异步执行的任务已经在进行了，因为串行队列一次只能执行一个任务，同步执行的任务也需要等待，这就造成了两者相互等待，死锁。  </p>
<p>同样的在串行队列上，同步嵌套，也会产生死锁。这就是我们常常遇到的主线程死锁问题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.my.serial5&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">      //...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//上面的代码，在第二个 dispatch_sync 执行时就会发生死锁</span><br><span class="line">//当前串行队列有任务正在执行，相互等待，死锁</span><br><span class="line"></span><br><span class="line">//在项目中经常遇到，切换到主线程执行的情况这时需要注意了</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    		//主线程死锁</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三方库 SDWebImage 提供一种解决方法 dispatch_main_async_safe(block)</span><br><span class="line">if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   dispatch_async(dispatch_get_main_queue(), block);</span><br><span class="line">&#125;</span><br><span class="line">//先判断当前任是否在主队列上，如果是直接执行任务就行了，不用切换到主队列上</span><br><span class="line">//否则的话用异步调用主队列，执行任务。这样可避免主线程死锁</span><br></pre></td></tr></table></figure>

<p>谨慎使用同步操作。其实在主线程队列中使用同步操作是一定会构成死锁的，所以建议在串行队列中不要使用同步操作。<br><br></p>
<h5 id="2-2-在并发队列上进行同步-异步操作"><a href="#2-2-在并发队列上进行同步-异步操作" class="headerlink" title="2.2 在并发队列上进行同步/异步操作"></a>2.2 在并发队列上进行同步/异步操作</h5><p>与上面串行队列操作类似：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;11 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;22 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;33 --- &quot;);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//11 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//22 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000021d1cc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//33 ---</span><br></pre></td></tr></table></figure>
<p>在并发队列上进行同步操作，所有任务顺序执行。<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;a --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;a --- %d %@&quot;, sum,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;aa --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;b --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;b --- %d %@&quot;, sum,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;bb --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;c --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            sum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;c --- %d %@&quot;, sum,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;cc ---&quot;);</span><br><span class="line"></span><br><span class="line">//aa --- &lt;NSThread: 0x600003a1e380&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//a --- &lt;NSThread: 0x600003a7c440&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">//bb --- &lt;NSThread: 0x600003a1e380&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//b --- &lt;NSThread: 0x600003a16ac0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">//cc ---</span><br><span class="line">//c --- &lt;NSThread: 0x600003a85240&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">//a --- 100000 &lt;NSThread: 0x600003a7c440&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">//b --- 100000 &lt;NSThread: 0x600003a16ac0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">//c --- 100000 &lt;NSThread: 0x600003a85240&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在并发队列上进行异步操作，另开线程各自执行，如上打印情况，只能确定 aa – bb – cc 这样的执行顺序，block 内的打印顺序不确定，<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">                sum += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;3 --- %d %@&quot;, sum, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//4 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000003d6a80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//3 --- 100000 &lt;NSThread: 0x6000003d6a80&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在并发队列中进行同步、异步嵌套，不会构成死锁。<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;4 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;5 --- %@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">//1 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//5 --- &lt;NSThread: 0x60000038e200&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">//2 --- &lt;NSThread: 0x6000003dc580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000003dc580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">//4 --- &lt;NSThread: 0x6000003dc580&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>在并发队列中进行异步、同步步嵌套，并发队列，可多任务并发处理，不会构成死锁。<br><br></p>
<h4 id="3、dispatch-barrier-async、dispatch-barrier-sync"><a href="#3、dispatch-barrier-async、dispatch-barrier-sync" class="headerlink" title="3、dispatch_barrier_async、dispatch_barrier_sync"></a>3、dispatch_barrier_async、dispatch_barrier_sync</h4><p>栅栏函数，像一个分界线，将同一个队列中的任务分开。分隔开的任务，前半部分任务执行完，栅栏函数执行，栅栏函数执行完，后半部分再执行。<br>类似的同步 sync、异步 async，同步函数等待任务执行完才返回，异步函数立即返回，无需等待任务完成。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        dispatch_queue_t queue = dispatch_queue_create(&quot;my.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --1 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --2 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        //等待栅栏函数执行完，再执行后面的任务</span><br><span class="line">        dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;%@ -- 分隔线 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --3 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">             NSLog(@&quot;%@ --4 &quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;-- end&quot;);</span><br><span class="line">        </span><br><span class="line">// -- end</span><br><span class="line">// &lt;NSThread: 0x6000024d4280&gt;&#123;number = 4, name = (null)&#125; --1</span><br><span class="line">// &lt;NSThread: 0x6000024a7bc0&gt;&#123;number = 6, name = (null)&#125; --2</span><br><span class="line">// &lt;NSThread: 0x6000024a7bc0&gt;&#123;number = 6, name = (null)&#125; -- 分隔线 </span><br><span class="line">// &lt;NSThread: 0x6000024a7bc0&gt;&#123;number = 6, name = (null)&#125; --3</span><br><span class="line">// &lt;NSThread: 0x6000024d4280&gt;&#123;number = 4, name = (null)&#125; --4</span><br></pre></td></tr></table></figure>
<p>注意，上面使用的自定义的队列 dispatch_queue_create()，如果使用 dispatch_get_global_queue() 队列则栅栏没有分割效果。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//如果将上面的代码，栅栏函数换成 dispatch_barrier_sync 同步的，打印内容如下</span><br><span class="line">//注意 end 打印位置，主线程被阻塞，等待 dispatch_barrier_sync 任务执行完成返回，然后才继续下面的任务</span><br><span class="line"></span><br><span class="line">// &lt;NSThread: 0x6000010cb480&gt;&#123;number = 4, name = (null)&#125; --2</span><br><span class="line">// &lt;NSThread: 0x6000010ed540&gt;&#123;number = 6, name = (null)&#125; --1</span><br><span class="line">// &lt;NSThread: 0x600001088f00&gt;&#123;number = 1, name = main&#125; -- 分隔线 </span><br><span class="line">// -- end</span><br><span class="line">// &lt;NSThread: 0x6000010ed540&gt;&#123;number = 6, name = (null)&#125; --3</span><br><span class="line">// &lt;NSThread: 0x6000010cb480&gt;&#123;number = 4, name = (null)&#125; --4</span><br></pre></td></tr></table></figure>

<br>

<h4 id="4、dispatch-after"><a href="#4、dispatch-after" class="headerlink" title="4、dispatch_after"></a>4、dispatch_after</h4><p>在指定时间后处理任务，可以使用 dispatch_after 函数来实现  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), </span><br><span class="line">               dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;done ---&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>dispatch_after 函数不是在指定时间后执行处理，而是在指定时间追加处理到 Dispatch Queue 中。上面例子，与在3秒后用 dispatch_async 函数追加 block 任务到 Main Dispatch Queue 的操作相同。<br>Main Dispatch Queue 在主线程的 RunLoop 中执行，在如每隔 1/60 秒执行的 RunLoop 中，block 最快在 3 秒后执行，最慢在 3秒+1/60秒后执行，如在 Main Dispatch Queue 有大量追加任务或主线程处理本身有延迟，这个时间会更长。  </p>
<br>

<h4 id="5、Dispatch-Group"><a href="#5、Dispatch-Group" class="headerlink" title="5、Dispatch Group"></a>5、Dispatch Group</h4><p>在多线程中想监控，追加到队列中的任务都全部完成后，然后再进行处理，这种情况可以使用 Dispatch Group。例如处理完页面所有数据后，最后再在主线程上刷新页面。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;1 --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;2 --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;3 --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;done --- %@&quot;, [NSThread currentThread]); &#125;);</span><br><span class="line"></span><br><span class="line">//2 --- &lt;NSThread: 0x600001969c80&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">//3 --- &lt;NSThread: 0x6000019fd800&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">//1 --- &lt;NSThread: 0x600001983500&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">//done --- &lt;NSThread: 0x600000fae280&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_group_wait 函数，在指定的时间内，等待追加到 group 的 队列中的任务是否执行完毕。<br>dispatch_group_wait 是一个同步操作，会阻塞线程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC);</span><br><span class="line">long result = dispatch_group_wait(group, time);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">    //追加到 group 的 队列中的任务全部执行完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<h4 id="6、dispatch-apply"><a href="#6、dispatch-apply" class="headerlink" title="6、dispatch_apply"></a>6、dispatch_apply</h4><p>dispatch_apply 函数按指定的次数将指定的 block 追加到指定的 Dispatch Queue 中，并等待全部处理执行结束。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;];</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_apply(array.count, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;--- %@ %@&quot;, array[index], [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;--- done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/images/2019/gcd-1.png" alt="">  </p>
<br>

<h4 id="7、Dispatch-Semaphore"><a href="#7、Dispatch-Semaphore" class="headerlink" title="7、Dispatch Semaphore"></a>7、Dispatch Semaphore</h4><p>Dispatch Semaphore 是持有计数的信号。  </p>
<ul>
<li>dispatch_semaphore_create 函数可以生成信号量，参数是信号量计数的初始值。  </li>
<li>dispatch_semaphore_wait 函数，当信号量值为 0 时等待，等待直到超时，参数可设置超时时长。信号量值大于等于 1 时，不等待，同时将信号量值减 1。  </li>
<li>dispatch_semaphore_signal 函数会让信号量值加 1，如果有通过dispatch_semaphore_wait 函数等待信号量值增加的线程，会由系统唤醒最先等待的线程执行。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p>在 iOS 开发时，经常遇到一个页面有多个网络数据请求的场景，等多个网络请求获取到数据后再去刷新页面，那么这是就可以使用 Dispatch Semaphore 可与 Dispatch Group<br>来实现这一功能，代码如下，两个链接分别加载两张图片，当两个图片都下载完成后，在一起显示在界面上：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *images = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    dispatch_semaphore_t semaphore1 = dispatch_semaphore_create(1);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        //开始下载第一张图片</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&quot;https://xxxx.png&quot;]];</span><br><span class="line">        NSString *path=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)    objectAtIndex:0];</span><br><span class="line">        NSString *filename=[path stringByAppendingPathComponent:@&quot;banner1.png&quot;];</span><br><span class="line">        //在该路径下创建图片文件，并将存储图片的数据存到本地</span><br><span class="line">        NSFileManager* fm = [NSFileManager defaultManager];</span><br><span class="line">        [fm createFileAtPath:filename contents:imageData attributes:nil];</span><br><span class="line">        </span><br><span class="line">        [images addObject:filename];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore1);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_semaphore_wait(semaphore1, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    dispatch_semaphore_t semaphore2 = dispatch_semaphore_create(0);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        //开始下载第二张图片</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfURL:[NSURL URLWithString:@&quot;https://xxxx.png&quot;]];</span><br><span class="line">        NSString *path=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)  objectAtIndex:0];</span><br><span class="line">        NSString *filename=[path stringByAppendingPathComponent:@&quot;banner2.png&quot;];</span><br><span class="line">        NSFileManager* fm = [NSFileManager defaultManager];</span><br><span class="line">        [fm createFileAtPath:filename contents:imageData attributes:nil];</span><br><span class="line">        [images addObject:filename];</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //初始化信号量计数为0，会一直等待下载图片</span><br><span class="line">    //上面的异步下载图片完成后会调用 dispatch_semaphore_signal 函数</span><br><span class="line">    // 然后信号量计数加 1，这时不在等待，该任务执行完成返回</span><br><span class="line">    dispatch_semaphore_wait(semaphore2, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    //当监控得到追加队列里的任务都完成后，调用本 block 任务</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        //当获取全部数据后，在主线程进行刷新页面</span><br><span class="line">        NSString *image1 = [images firstObject];</span><br><span class="line">        if (image1 &amp;&amp; [image1 isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            self.imageView1.image = [[UIImage alloc] initWithContentsOfFile:image1];;</span><br><span class="line">        &#125;</span><br><span class="line">        NSString *image2 = [images lastObject];</span><br><span class="line">        if (image2 &amp;&amp; [image2 isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            self.imageView2.image = [[UIImage alloc] initWithContentsOfFile:image2];;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h4 id="8、dispatch-once"><a href="#8、dispatch-once" class="headerlink" title="8、dispatch_once"></a>8、dispatch_once</h4><p>dispatch_once 函数时保证在应用程序执行中只执行一次指定处理的 API。<br>经常用在生成单例对象的时候。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    // code to be executed once</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发 API</a><br><a href="https://mp.weixin.qq.com/s/NKupCS1RsAGhbzhCpYl2mA" target="_blank" rel="noopener">iOS 如何高效的使用多线程</a><br><a href="https://www.jianshu.com/p/39d6edb54d24" target="_blank" rel="noopener">深入浅出 iOS 并发编程</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    MA806P
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yupeng.fun/2019/10/30/gcd/" title="GCD 多线程 小结">http://yupeng.fun/2019/10/30/gcd/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OC/" rel="tag"> <i class="fa fa-tag"></i> OC</a>
          
            <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"> <i class="fa fa-tag"></i> 基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/21/nginx/" rel="next" title="CentOS 7 安装 Nginx">
                <i class="fa fa-chevron-left"></i> CentOS 7 安装 Nginx
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/11/swift-oc/" rel="prev" title="Swift、OC混用">
                Swift、OC混用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avator-default.png"
                alt="MA806P" />
            
              <p class="site-author-name" itemprop="name">MA806P</p>
              <p class="site-description motion-element" itemprop="description">在希望的田野上 折腾着</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MA806P" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:mayp126@126.com" target="_blank" title="邮箱">
                      
                        <i class="fa fa-fw fa-envelope"></i>邮箱</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程"><span class="nav-number">1.</span> <span class="nav-text">线程与进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD-简介"><span class="nav-number">2.</span> <span class="nav-text">GCD 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、Dispatch-Queue"><span class="nav-number">2.1.</span> <span class="nav-text">1、Dispatch Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-创建队列的方法："><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 创建队列的方法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-串行队列"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 串行队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-并发队列"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 并发队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、dispatch-sync-同步操作函数、dispatch-async-异步操作函数"><span class="nav-number">2.2.</span> <span class="nav-text">2、dispatch_sync 同步操作函数、dispatch_async 异步操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-在串行队列上进行同步-异步操作"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 在串行队列上进行同步/异步操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-在并发队列上进行同步-异步操作"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 在并发队列上进行同步/异步操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、dispatch-barrier-async、dispatch-barrier-sync"><span class="nav-number">2.3.</span> <span class="nav-text">3、dispatch_barrier_async、dispatch_barrier_sync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、dispatch-after"><span class="nav-number">2.4.</span> <span class="nav-text">4、dispatch_after</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、Dispatch-Group"><span class="nav-number">2.5.</span> <span class="nav-text">5、Dispatch Group</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、dispatch-apply"><span class="nav-number">2.6.</span> <span class="nav-text">6、dispatch_apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、Dispatch-Semaphore"><span class="nav-number">2.7.</span> <span class="nav-text">7、Dispatch Semaphore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、dispatch-once"><span class="nav-number">2.8.</span> <span class="nav-text">8、dispatch_once</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">3.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MA806P</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
